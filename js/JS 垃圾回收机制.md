### JS 垃圾回收机制
JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。

什么是垃圾
一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

如何检垃圾

有两种算法：标记清除、引用计数。引用计数不太常用，标记清除较为常用。

#### 可达性
JavaScript 中内存管理的主要概念是可达性。简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。

##### 基本的固有可达值，由于显而易见的原因无法删除。例如:

	* 本地函数的局部变量和参数
	* 当前嵌套调用链上的其他函数的变量和参数
	* 全局变量
	* 还有一些其他的，内部的

这些值称为根。

JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象。 

#### “标记-清除”算法

基本的垃圾回收算法称为“标记-清除”，这是javascript中最常用的垃圾回收方式。它定期执行以下“垃圾回收”步骤:

当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

##### 优化:

	* 分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
	* 增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
	* 空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。


#### 引用计数算法
所谓"引用计数"是指语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。

### 内存泄漏
虽然JavaScript会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。

1.全局变量
2.被遗忘的计时器或回调函数
3.闭包

#### 内存泄漏的识别方法

新版本的chrome在 performance 中查看：
步骤:
	* 打开开发者工具 Performance
	* 勾选 Screenshots 和 memory
	* 左上角小圆点开始录制(record)
	* 停止录制


就可以看到内存在周期性的回落也可以看到垃圾回收的周期,如果垃圾回收之后的最低值(我们称为min),min在不断上涨,那么肯定是有较为严重的内存泄漏问题。

#### 避免内存泄漏的一些方式：

	* 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收
	* 注意程序逻辑，避免“死循环”之类的
	* 避免创建过多的对象

总而言之需要遵循一条原则：不用了的东西要及时归还
